{"version":3,"file":"static/js/635.d12a91e2.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","logic.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","const { Rune } = window;\n/**\n * declared a const to define different stages of the game\n * which will then help us conditionally render views in different components\n */\n\nconst ROUND_STAGE_MAP = [\n  'acceptingPlayers',\n  'displayRole',\n  'awaitingStart',\n  'submitDefinition',\n  'decisionMaking',\n  'announcement',\n  'announceWinner'\n];\n\nRune.initLogic({\n  minPlayers: 4,\n  maxPlayers: 4,\n  setup: (allPlayerIds) => {\n    const scores = {};\n    for (let playerId of allPlayerIds) {\n      scores[playerId] = 0;\n    }\n    return {\n      startGame: 0,\n      continueGame: 0, \n\n      scores: {},\n      currentRoundStage: 'acceptingPlayers',\n      gameOver: false,\n      judgeOrder: [], //Judge order prevents the same person from being the judge again - We follow this judge order with the rounds - And Reset this judge order once the game is over - I think Rune does the resetting of the state for us \n      currentJudge: '', // This the string that represents the currentPlayerId of the Judge\n      judgeIndex: null, //Is a randomly assigned index between 0 and 3 \n      pickedWords: {},\n      definitions: {},\n      canShowDefinitions: false,\n      word: '',\n      winner: '',\n      currentRoundWinner: undefined,\n      roundNum: 1\n    };\n  },\n\n  actions: {\n    assignRoles: (_, { game, allPlayerIds }) => {\n      //This is the logic to make sure all players have entered and then when all players have entered then we create the random judge index. Once the game begins, this function will reassign increment the judget index which in turn will change judge.\n      if (game.startGame < 4) {\n        game.startGame++;\n      }\n      if (game.startGame === 4) {\n        if (game.judgeIndex === null) {\n          const initialIndex = Math.floor(Math.random() * 3);\n          game.judgeIndex = initialIndex;\n        }\n\n        //assigns the next judge index during the game.\n        else if (game.judgeIndex === 3) {\n          game.judgeIndex = 0;\n        } else {\n          game.judgeIndex++;\n        }\n      }\n    },\n\n    continueToNextScreen: (_, {game, allPlayerIds}) => {\n      if(game.continueGame < 4) {\n        game.continueGame++\n      }\n    },\n\n    //This logic adds the order in which the judges will be picked throughout the game.\n    assignJudgeArray: (currentPlayerID, { game, allPlayerIds }) => {\n      /**\n       * We only want to set up the initial judge order array\n       * in round 1 when players haven't been added to it yet.\n       * After the initial judge order array is setup, we do not need\n       * to modify it again.\n       */\n      if (game.roundNum === 1) {\n        game.judgeOrder = [...game.judgeOrder, currentPlayerID];\n      }\n      if (game.judgeIndex !== null) {\n        game.currentJudge = game.judgeOrder[game.judgeIndex];\n      }\n    },\n\n    //initial scores\n    assignInitialScores: (currentPlayerID, { game, allPlayerIds }) => {\n      for (let player in allPlayerIds) {\n        if (!game.scores[allPlayerIds[player]]) {\n          game.scores[allPlayerIds[player]] = 0;\n        }\n      }\n    },\n\n    //this function will add to the players score as the game progresses.\n    incrementScore: (currentPlayerID, { game, allPlayerIds }) => {\n      game.scores[currentPlayerID]++;\n\n      //Once the jude picks a winning answer, This line updates the currently picked winner Id in Rune state\n      game.currentRoundWinner = currentPlayerID\n      game.currentRoundStage = ROUND_STAGE_MAP[5]\n\n    },\n\n    continueToNextRound: (_,{game}) => {\n      const {scores } = game\n      game.roundNum = game.roundNum + 1\n      game.startGame = 0\n      game.continueGame = 0\n      game.definitions = {}\n      game.canShowDefinitions = false\n      \n      for(let player in scores) {\n        if(scores[player] >= 3) {\n          game.winner = player\n        }\n      }\n      if(game.winner !== '') {\n        game.gameOver = true\n        game.currentRoundStage = ROUND_STAGE_MAP[6]\n      } else {\n        game.currentRoundStage = ROUND_STAGE_MAP[0]\n      }\n    },\n    \n    //This function generates a random index that corresponds to our random word array. It checks to see if the index has already been generated, if not, it submits the new word, if it has then it regerates index.\n    \n     determineRoundStage: (_, { game }) => {\n      switch (game.currentRoundStage) {\n        case 'acceptingPlayers': {\n          if (game.startGame === 4) {\n            game.currentRoundStage = ROUND_STAGE_MAP[1];\n          }\n          break;\n        }\n        case 'displayRole':{\n          if(game.continueGame === 4) {\n          game.currentRoundStage = ROUND_STAGE_MAP[2]\n          }\n          break\n        }\n        case 'awaitingStart': {\n            game.currentRoundStage = ROUND_STAGE_MAP[3];\n          break;\n        }\n        case 'submitDefinition': {\n          if (game.canShowDefinitions)\n            game.currentRoundStage = ROUND_STAGE_MAP[4];\n          break;\n        }\n        case 'decisionMaking': {\n          break;\n        }\n        case 'announcement': {\n          break;\n        }\n        case 'announceWinner':{\n          break;\n        }\n        default: {\n          game.currentRoundStage = ROUND_STAGE_MAP[0];\n        }\n      }\n    },\n    \n    generateWord: (_, { game }) => {\n      let possibleIndex = Math.floor(Math.random() * 100);\n      while (game.pickedWords[possibleIndex]) {\n        possibleIndex = Math.floor(Math.random() * 100);\n      }\n      game.pickedWords[possibleIndex] = possibleIndex;\n      game.wordIndex = possibleIndex;\n    },\n    addDefinition: (playerInputAndIdObj, { game }) => {\n      //store all the inputs as objects in the definition array in game state\n      const { currentPlayerId, inputVal } = playerInputAndIdObj;\n      game.definitions[currentPlayerId] = inputVal;\n      if (Object.keys(game.definitions).length === 3) {\n        game.canShowDefinitions = true;\n      }\n    },\n  },\n  events: {\n    /**\n     * This callback runs when additional players join after the server is running.\n     */\n    playerJoined: (playerId, { game }) => {\n      game.playerScore[playerId] = 0;\n    },\n  },\n});\n\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["_toConsumableArray","arr","Array","isArray","arrayLikeToArray","iter","Symbol","iterator","from","unsupportedIterableToArray","TypeError","Rune","window","ROUND_STAGE_MAP","initLogic","minPlayers","maxPlayers","setup","allPlayerIds","_step","scores","_iterator","o","allowArrayLike","it","length","i","F","s","n","done","value","e","_e","f","err","normalCompletion","didErr","call","step","next","_e2","_createForOfIteratorHelper","startGame","continueGame","currentRoundStage","gameOver","judgeOrder","currentJudge","judgeIndex","pickedWords","definitions","canShowDefinitions","word","winner","currentRoundWinner","undefined","roundNum","actions","assignRoles","_","_ref","game","initialIndex","Math","floor","random","continueToNextScreen","_ref2","assignJudgeArray","currentPlayerID","_ref3","concat","assignInitialScores","_ref4","player","incrementScore","_ref5","continueToNextRound","_ref6","determineRoundStage","_ref7","generateWord","_ref8","possibleIndex","wordIndex","addDefinition","playerInputAndIdObj","_ref9","currentPlayerId","inputVal","Object","keys","events","playerJoined","playerId","_ref10","playerScore"],"sourceRoot":""}